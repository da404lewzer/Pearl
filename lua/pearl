
--[[
 * Pearl EnderWeb Browser by TurtleScripts
 * Written by da404lewzer
 * This is delivered to you without warranty under the Creative Commons Attribution-ShareAlike 3.0 Unported License (http://creativecommons.org/licenses/by-sa/3.0/).
 * 
 * Usage: After launching you load pages by typing in their six-digit number.
 * 
 * Changelog:
 * + Added Image Background/Fill support
 * + Added Image Text Overlay support
 * + Added Animation Support
 * + Changed scrolling to select links and enter will load them
 * + Tons of optimizations to the drawing
]]

--[[LOCAL VARS]]

local debugOutput = {} --outputs to an side monitor
local debugSide = "right"

local versionStr="1.2-beta"
local userAgent="EnderWeb/1.0 (Minecraft; ComputerCraft; Forge) " .. string.gsub(os.version(), " ", "/") .. " Pearl/" .. versionStr

local running = true
local w,h = term.getSize()

--[[LOCAL DEPENDENCIES]]

local function setColors(monitor, bg, fg, bg2, fg2)
   if monitor then
    if monitor.isColor() then
      monitor.setBackgroundColor(bg)
      monitor.setTextColor(fg)
    else
      monitor.setBackgroundColor(bg2)
      monitor.setTextColor(fg2)
    end
  end
end
local function lpad(str, len, char)
    if char == nil then char = ' ' end
    local i = len - #str
    if i >= 0 then
      return string.rep(char, i) .. str
    else
      return str
    end
end
local function rpad(str, len, char)
    if char == nil then char = ' ' end
    local i = len - #str
    if i >= 0 then
      return str .. string.rep(char, i)
    else
      return str
    end
end
local function drawScreen(monitor)
--TODO
end

--[[Stolen Shamelessly from nPaintPro - http://pastebin.com/4QmTuJGU]]
local function getColourOf(hex)
  local value = tonumber(hex, 16)
  if not value then return nil end
  value = math.pow(2,value)
  return value
end

local function drawPictureTable(mon, xinit, yinit, width, scanLines, overLines, align, fill, bgcolor, actuallyDraw)
    
  local imageHeight = math.max(#scanLines, #overLines)
  
  if not actuallyDraw then
    return imageHeight
  end
  
  local imageWidth = 0
  for y=1,#scanLines do
    for x=1,#scanLines[y] do
      imageWidth = math.max(imageWidth, x)
    end
  end
  local overText = {}
  local overColor = {}
  local curText = " "
  local curColor = "f"
  for y=1,#overLines do
    overText[y] = {}
    overColor[y] = {}
    local n = 1    
    for x=1,#overLines[y] do
      local cur = string.sub(overLines[y], x, x)
      local prev = ""
      local peek = ""
      if x > 1 then prev = string.sub(overLines[y], x-1, x-1) end
      if x <= #overLines[y] then peek = string.sub(overLines[y], x+1, x+1) end
      
      local advance = false
      if cur == "^" and peek == "^" then
        curText = "^"
      elseif cur == "^" then
        curColor = peek
      elseif prev ~= "^" then
        curText = cur
        advance = true
      end
          
      overText[y][n] = curText
      overColor[y][n] = curColor
      
      if advance then n = n + 1 end
    end
    imageWidth = math.max(imageWidth, #overText[y])
  end
  
  local alignOffset = 0
  if align == "center" then
    alignOffset = width /2 - imageWidth /2
  elseif align == "right" then
    alignOffset = width - imageWidth
  end
  
  
  
  for y=1,imageHeight do
    
    if fill then
      mon.setBackgroundColour(bgcolor)
      mon.setCursorPos(1, yinit + y-1)
      mon.write(string.rep(" ", w))
    end
    for x=1,imageWidth do
      local bgData = " "
      local fgText = " "
      local fgColor = "f"
      if scanLines[y] then bgData = string.sub(scanLines[y], x, x) end
      if overText[y] and overText[y][x] then fgText = overText[y][x] end
      if overColor[y] and overColor[y][x] then fgColor = overColor[y][x] end
      
      mon.setCursorPos(xinit + x-1 + alignOffset, yinit + y-1)
      
      --[[SET BG]]
      if scanLines[y] then
        local col = getColourOf(bgData)
        if col then
          if mon.isColor() then
            mon.setBackgroundColour(col)
          else
            if bgData == "c" or bgData == "5" or bgData == " " then
              mon.setBackgroundColour(colors.white)
            else
              mon.setBackgroundColour(colors.black)
            end
          end
        else
          if bgcolor ~= "" then
            mon.setBackgroundColour(bgcolor)
          else
            mon.setBackgroundColour(colors.white)
          end
        end
      end

      --[[SET FG]]
      local colfg = getColourOf(fgColor)
      if colfg then
        if mon.isColor() then
          mon.setTextColour(colfg)
        else
          if fgColor == "c" or fgColor == "5" or fgColor == "0" then
            mon.setTextColour(colors.white)
          else
            mon.setTextColour(colors.black)
          end
        end
      end
      
      --[[DRAW]]
      mon.write(fgText)
      
		end
	end
  
  return imageHeight
  
end
--[[End Theft]]

--[[START PROGRAM]]

local args = {...}
local currentPage = {}
local currentPageID = "000000"
local localPageDOM = {}
local currentlySelected = nil
local localFrame = 1
local pageScroll = 0
local totalLines = 0
local linkScrollAmount = 1



local function writeTextRAW(monitor, x, y, text)
  monitor.setCursorPos(x, y)
  monitor.write(text)
end

local function writeTextBlock(actuallyDraw, monitor, x, y, width, text, align, fill)
  
  local words = {}
  
  if text ~= nil then
    for word in string.gmatch(text, "%S+")   do table.insert(words, word) end
  end
  if #words == 0 then
    table.insert(words, " ")
  end
  
  local lines = {}
  
  local curLine = 1
  local strLen = 0
  
  for i=1, #words do
  
    local word = words[i]
    
    if word ~= nil then
      
      strLen = strLen + #word
      
      if lines[curLine] == nil then
        lines[curLine] = {}
      end

      local wordSpaceLen = #lines[curLine]-1   
      
      if strLen + wordSpaceLen >= width then
        curLine = curLine + 1
        lines[curLine] = {}
        strLen = #word --this needs to be carried over so we don't accidentally let words hang off the screen
      end
      
      table.insert(lines[curLine], word)
    
    end
    
  end
  
  if not actuallyDraw then
    return curLine
  end
  
  for i=1, #lines do
    
    local line = lines[i]
    local text = table.concat(line, " ")
    
    local offX = 0
    if align == "left" then
      offX = 0
    elseif align == "center" then
      offX = width/2 - (string.len(text)-1)/2
    elseif align == "right" then
      offX = width - string.len(text)
    end
    if fill == true then
      writeTextRAW(monitor, x, y + i-1, string.rep(" ", width))
    end
    writeTextRAW(monitor, x + offX, y + i-1, text)
  end
  
  return curLine
  
end

function newNode(name)
  local node = {}
  node.___value = nil
  node.___name = name
  node.___children = {}
  node.___props = {}
  node.___frame = nil
  node.___frameStack = {}
  node.___isSelected = false
  node.___renderTop = nil
  node.___renderHeight = nil
  
  function node:value() return self.___value end
  function node:setValue(val) self.___value = val end
  function node:name() return self.___name end
  function node:setName(name) self.___name = name end
  function node:children() return self.___children end
  function node:numChildren() return #self.___children end
  function node:addChild(child)
    if self[child:name()] ~= nil then
      if type(self[child:name()].name) == "function" then
        local tempTable = {}
        table.insert(tempTable, self[child:name()])
        self[child:name()] = tempTable
      end
      table.insert(self[child:name()], child)
    else
      self[child:name()] = child
    end
    table.insert(self.___children, child)
  end

  function node:setRenderTop(val) self.___renderTop = val end
  function node:getRenderTop() return self.___renderTop end
  function node:setRenderHeight(val) self.___renderHeight = val end
  function node:getRenderHeight() return self.___renderHeight end
  function node:setSelected(isSelected) self.___isSelected = isSelected end
  function node:getSelected() return self.___isSelected end
  function node:getFrame() 
    if self.___frame == nil then
      local childrenCount = self:numChildren()
      
      --setup our framestack
      
      if self["@mode"] == "linear" then
        for i=1,childrenCount do 
          self.___frameStack[i] = i
        end
      elseif self["@mode"] == "bounce" then
        local n = 0
        if self["@direction"] == "backward" then
          for i=childrenCount,1,-1 do 
            n = n + 1
            self.___frameStack[n] = i
          end
          for i=1,childrenCount do 
            n = n + 1
            self.___frameStack[n] = i
          end
        else
          for i=1,childrenCount do 
            n = n + 1
            self.___frameStack[n] = i
          end
          for i=childrenCount,1,-1 do 
            n = n + 1
            self.___frameStack[n] = i
          end
        end
      end
      
      if self["@direction"] == "backward" then
        self.___frame = #self.___frameStack
      else
        self.___frame = 1
      end
      
    end
    
    debugOutput.ff = self.___frame
    debugOutput.fs = #self.___frameStack
    debugOutput.fc = self.___frameStack[self.___frame]
    return self.___frameStack[self.___frame]
  end
  function node:advanceFrame()
    local frameStackCount = #self.___frameStack
    local loop = self["@loop"] == "true"
    
    local tmpFrame = self.___frame
    
    if self["@direction"] == "backward" then
      tmpFrame = tmpFrame - 1 
      if tmpFrame < 1 then
        if loop then
          tmpFrame = frameStackCount
        else
          tmpFrame = 1
        end
      end
    else
      tmpFrame = tmpFrame + 1
      if tmpFrame > frameStackCount then
        if loop then
          tmpFrame = 1
        else
          tmpFrame = frameStackCount
        end
      end
    end
    
    self.___frame = tmpFrame
  end

  function node:properties() return self.___props end
  function node:numProperties() return #self.___props end
  function node:addProperty(name, value)
    local lName = "@" .. name
    if self[lName] ~= nil then
      if type(self[lName]) == "string" then
        local tempTable = {}
        table.insert(tempTable, self[lName])
        self[lName] = tempTable
      end
      table.insert(self[lName], value)
    else
      self[lName] = value
    end
    table.insert(self.___props, { name = name, value = self[name] })
  end

  return node
end

local function FromXmlString(value)
  value = string.gsub(value, "&#x([%x]+)%;",
    function(h)
      return string.char(tonumber(h, 16))
    end);
  value = string.gsub(value, "&#([0-9]+)%;",
    function(h)
      return string.char(tonumber(h, 10))
    end);
  value = string.gsub(value, "&quot;", "\"")
  value = string.gsub(value, "&apos;", "'")
  value = string.gsub(value, "&gt;", ">")
  value = string.gsub(value, "&lt;", "<")
  value = string.gsub(value, "&amp;", "&")
  value = string.gsub(value, "&nbsp;", " ")
  return value;
end

local function ParseArgs(node, s)
  string.gsub(s, "(%w+)=([\"'])(.-)%2", function(w, _, a)
    node:addProperty(w, FromXmlString(a))
  end)
end

local function parseTree(xmlText)
  local stack = {}
  local top = newNode()   
  table.insert(stack, top)
  local ni, c, label, xarg, empty
  local i, j = 1, 1
  while true do
    ni, j, c, label, xarg, empty = string.find(xmlText, "<(%/?)([%w_:]+)(.-)(%/?)>", i)
    if not ni then break end
    local text = string.sub(xmlText, i, ni - 1);
    
    if not string.find(text, "^%s*$") then
      
      local lVal = (top:value() or "") .. FromXmlString(text)
      stack[#stack]:setValue(lVal)
    end
    if empty == "/" then -- empty element tag
      local lNode = newNode(label)
      ParseArgs(lNode, xarg)
      top:addChild(lNode)
    elseif c == "" then -- start tag
      local lNode = newNode(label)
      ParseArgs(lNode, xarg)
      table.insert(stack, lNode)
      top = lNode
    else -- end tag
      local toclose = table.remove(stack) -- remove top

      top = stack[#stack]
      if #stack < 1 then
        error("XmlParser: nothing to close with " .. label)
      end
      if toclose:name() ~= label then
        error("XmlParser: trying to close " .. toclose.name .. " with " .. label)
      end
      top:addChild(toclose)
    end
    i = j + 1
  end
  local text = string.sub(xmlText, i);
  if #stack > 1 then
    error("XmlParser: unclosed " .. stack[#stack]:name())
  end
  return top
end

local function updateTitle()
  setColors(term, colors.lightGray, colors.gray, colors.white, colors.black)
  --writeTextRAW(term, 1, 1, string.rep(" ", w), "left")
  writeTextBlock(true, term, 1, 1, w, "@ " .. currentPageID, "left", true)
  --writeRightText(term, 1, 1, "0 bytes")
end

local function updateTitleKeying(keyCode)
  setColors(term, colors.lightGray, colors.gray, colors.white, colors.black)
  writeTextBlock(true, term, 1, 1, w, "@ " .. string.rep("-", 6), "left", false)
  setColors(term, colors.lightGray, colors.black, colors.white, colors.black)
  writeTextBlock(true, term, 1, 1, w, "@", "left", false)
  writeTextBlock(true, term, 9 - #keyCode, 1, w, keyCode, "left", false)
end

local function updatePage()
  updateTitle()
  setColors(term, colors.white, colors.black, colors.white, colors.black)
end

local function getColor(color, default)
  if color == "white" then
    return colors.white
  elseif color == "orange" then
    return colors.orange
  elseif color == "magenta" then
    return colors.magenta
  elseif color == "lightblue" then
    return colors.lightBlue
  elseif color == "yellow" then
    return colors.yellow
  elseif color == "lime" then
    return colors.lime
  elseif color == "pink" then
    return colors.pink
  elseif color == "gray" or color == "grey" then
    return colors.gray
  elseif color == "lightgray" or color == "lightgrey" then
    return colors.lightGray
  elseif color == "cyan" then
    return colors.cyan
  elseif color == "purple" then
    return colors.purple
  elseif color == "blue" then
    return colors.blue
  elseif color == "brown" then
    return colors.brown
  elseif color == "green" then
    return colors.green
  elseif color == "red" then
    return colors.red
  elseif color == "black" then
    return colors.black
  end
  return default
end

local function renderDOM(actuallyDraw)

  local editMode = false

  local body = localPageDOM.page.body
  local children = body:children();
  
    
  local defaultColor = colors.gray
  local defaultBGColor = colors.white
    
  if body["@color"] ~= nil then
    defaultColor = getColor(body["@color"], "black")
  end
  if body["@bgcolor"] ~= nil then
    defaultBGColor = getColor(body["@bgcolor"], "white")
  end
      
  if actuallyDraw then
    term.setTextColor(defaultColor)
    term.setBackgroundColor(defaultBGColor)
    term.clear()
  
    updatePage()
  end
  
  totalLines = 0 --global
  
  local pageOffset = 1 + pageScroll + 1
  local extraOffset = 0 
  
  local selectionColor = colors.lightGray
  
  --totalLines = #children --fix
  for i=1, #children do
    local child = children[i]
    
    
    local setColor = defaultColor
    local setBGColor = defaultBGColor
    if child["@color"] ~= nil then
      setColor = getColor(child["@color"], "gray")
    end
    if child["@bgcolor"] ~= nil then
      setBGColor = getColor(child["@bgcolor"], "white")
    end
    
    if actuallyDraw then
      term.setTextColor(setColor)
      term.setBackgroundColor(setBGColor)
    end
    
    local currentChildHeight = 0 --to be calculated (and set on the child) below
    local currentChildTop = pageOffset+totalLines
    
    if child:name() == "div" then
      local fill = child["@fill"] ~= nil and child["@fill"] == "true"
      local align = "left"
      if child["@align"] ~= nil then
        align = child["@align"]
      end
      
      if editMode and child:getSelected() then
        term.setBackgroundColor(selectionColor)
        term.setTextColor(colors.white)
        fill = true
      end
      currentChildHeight = writeTextBlock(actuallyDraw, term, 1, currentChildTop, w, child:value(), align, fill)
    
    elseif child:name() == "drawing" then  
      
      
      local curImage = ""
      local curOverlay = ""
      if child.image ~= nil then
        curImage = child.image:value()
      end
      if child.overlay ~= nil then
        curImage = child.overlay:value()
      end
      
      local align = "left"
      if child["@align"] ~= nil then align = child["@align"] end
      
      local fill = child["@fill"] ~= nil and child["@fill"] == "true"
      
      if child.anim ~= nil then
        local anim = child.anim
        local animChildren = anim:children()
        local f = anim:getFrame() --(localFrame % anim:numChildren()) + 1
        anim:advanceFrame()
        local frame = animChildren[f]
        
               
        if frame:numChildren() > 0 then
          curImage = nil
          curOverlay = nil
          if frame.data ~= nil then
            curImage = frame.data:value()
          end
          if frame.overlay ~= nil then
            curOverlay = frame.overlay:value()
          end
        end
      end
      
      local scanLines = {}
      local overLines = {}      
      
      local lines = ""
      if curImage then 
        lines = string.gsub(curImage, "[\r\n]?", "")
        for scanLine in string.gmatch(lines, "[^+]+")   do table.insert(scanLines, scanLine) end
      end
      local overlay = ""
      if curOverlay then 
        overlay = string.gsub(curOverlay, "[\r\n]?", "")
        for overLine in string.gmatch(overlay, "[^+]+")   do table.insert(overLines, overLine) end
      end

      
      if editMode and child:getSelected() then
        setBGColor = selectionColor
        fill = true
      end
      
      currentChildHeight = drawPictureTable(term, 1, currentChildTop, w, scanLines, overLines, align, fill, setBGColor, actuallyDraw);
    
    elseif child:name() == "listing" then
      if actuallyDraw then
        if editMode and child:getSelected() then
          term.setBackgroundColor(selectionColor)
        end
        term.setTextColor(colors.lightGray)
        writeTextBlock(true, term, 1, currentChildTop, w, string.rep(".", w), "left", true)
        term.setTextColor(setColor)
        writeTextBlock(true, term, 1, currentChildTop, w, child:value(), "left", false)
        
        if child:getSelected() then
          term.setBackgroundColor(colors.blue)
          term.setTextColor(colors.white)
          fill = true
        else
          term.setTextColor(colors.blue)
        end
        writeTextBlock(true, term, 1, currentChildTop, w, child["@id"], "right", false)
      end
      currentChildHeight = 1
      
    else
      if editMode and actuallyDraw and child:getSelected() then
        term.setBackgroundColor(selectionColor)
        term.setTextColor(colors.white)
        fill = true
        writeTextBlock(true, term, 1, currentChildTop, w, " ", "left", true)
      end
      currentChildHeight = 1
    end
    
    child:setRenderTop(currentChildTop - pageScroll - 1)
    child:setRenderHeight(currentChildHeight)
    totalLines = totalLines + currentChildHeight
    
  end

  updatePage()
end

local function setPageScroll(scroll)

  local pageScrollBefore = pageScroll
  pageScroll = scroll
  
  return pageScrollBefore ~= pageScroll 
  
end
local function getPageScroll(tmpScroll)
  local scrollDiff = -(totalLines - h + 1)
  if tmpScroll > 0 then tmpScroll = 0 end
  if math.abs(totalLines) > h-1 then
    if tmpScroll < scrollDiff then tmpScroll = scrollDiff end
  else
    tmpScroll = 0
  end
  return tmpScroll
end

local function scrollPage(amt)
  return setPageScroll(getPageScroll(pageScroll + amt))
end

local function loadPage(id)
  local headers = {
    [ "User-Agent" ] = userAgent
  }
  local pageResult = http.get( "http://api.enderweb.com/getPage/" .. id, headers )
  localPageDOM = parseTree(pageResult.readAll())
  pageResult.close() --Just in case
  
  localFrame = 1
  linkScrollAmount = 1
  pageScroll = 0
  currentlySelected = nil
  
  renderDOM(false)
  doDOMScroll(0)
  
end

--saveSettings()

function updateAllTheThings()
    term.setTextColor(colors.green)
    term.setBackgroundColor(colors.black)
    term.clear()
    term.setCursorPos(1,1)
    shell.run("market get gjdi84 pearl y")
    currentPageID = '001300'
    loadPage('001300')
end

function getScreenBounds()
  return 2 - pageScroll, h - pageScroll
end

function doDOMScroll(direction)

  local linkMode = true

  local body = localPageDOM.page.body
  local children = body:children();
  
  local tmpScrollEligible = {}
  local tmpLinkEligible = {}
  local eligibleCount = 0
  local prev = nil
  local cur = nil
  
  for i=1, #children do
    local child = children[i]    
    table.insert(tmpScrollEligible, child)
    if child:name() == "listing" then  
      table.insert(tmpLinkEligible, child)
    end    
  end
  
  local a,b = getScreenBounds()
  local tmpLinkScrollAmount = linkScrollAmount
  for attempt=1, totalLines do
    tmpLinkScrollAmount = tmpLinkScrollAmount + direction
    
    if tmpLinkScrollAmount < 1 then tmpLinkScrollAmount = 1 end
    if tmpLinkScrollAmount > totalLines then tmpLinkScrollAmount = totalLines end
    
    if currentlySelected ~= nil then
      local curTop = currentlySelected:getRenderTop() + 1
      local curHeight = currentlySelected:getRenderHeight()
      
      local doesChildGoOffBottom = curTop + curHeight > b
      local doesChildGoOffTop = curTop < a
      
      if direction > 0 then
    
        if doesChildGoOffBottom then
          tmpLinkScrollAmount = b
        else
          tmpLinkScrollAmount = curTop + curHeight -1
        end
        
      elseif direction < 0 then
    
        if doesChildGoOffTop then
          tmpLinkScrollAmount = a-2
        else
          tmpLinkScrollAmount = curTop-2
        end
    
      end
      
    end
    
    if tmpLinkScrollAmount < 1 then tmpLinkScrollAmount = 1 end
    if tmpLinkScrollAmount > totalLines then tmpLinkScrollAmount = totalLines end
    
    linkScrollAmount = tmpLinkScrollAmount
    
    
    
    local curLine = 0
    for k,child in pairs(tmpScrollEligible) do
      local childTop = child:getRenderTop()
      local childHeight= child:getRenderHeight()
      
      local selected = linkScrollAmount >= childTop and linkScrollAmount < childTop + childHeight
      
      child:setSelected(selected)
      
      if selected then
        currentlySelected = child
      end
    end
    
    if linkMode and currentlySelected:name() == "listing" then
      break
    end
    
  end
  
  if currentlySelected then
    local curTop = currentlySelected:getRenderTop() + 1
    local curHeight = currentlySelected:getRenderHeight()
    local curLine = linkScrollAmount + 1
    
    debugOutput.curTop = curTop
    debugOutput.curHeight = curHeight
    
    
    if direction > 0 and curLine - 1 + curHeight > b then
      scrollPage(-(curLine-b))
    elseif direction < 0 and curLine - 1 < a then
      scrollPage(-(curLine-a))
    end
  end
  
  
  
end


loadPage('000000')

if args[1] == "update" then
  updateAllTheThings()
--elseif args[1] then
--  currentPageID = args[1]
end

loadPage(currentPageID)

local isKeyingCode = false
local keyCode = ""
local doKeyingSubmit = false

local updateSpeed = 0.125
local timer = os.startTimer(0)

local lastUpdateTime = os.clock()
local isFirst = true


  if debugSide then
    local monitor = peripheral.wrap( debugSide )
    if monitor then      
      monitor.setBackgroundColor(colors.black)
      monitor.setTextColor(colors.white)
      monitor.clear()
    end
  end

while running do

  local currentTime = os.clock()
  
  local doScrollPage = 0 -- positive or negative when scrollling, 0 == off
  local doJumpPage = 1 -- negative when jumping, 1 == off

  local event, p1,p2,p3 = os.pullEvent()
  
  local triggerDomRender = false
  if isFirst then
    triggerDomRender = true
    isFirst = false
  end
  
  if event == "key" then 
		if p1 == keys.one or p1 == keys.numPad1 then
      keyCode = keyCode .. "1"
      isKeyingCode = true
		elseif p1 == keys.two or p1 == keys.numPad2 then
      keyCode = keyCode .. "2"
      isKeyingCode = true
		elseif p1 == keys.three or p1 == keys.numPad3 then
      keyCode = keyCode .. "3"
      isKeyingCode = true
		elseif p1 == keys.four or p1 == keys.numPad4 then
      keyCode = keyCode .. "4"
      isKeyingCode = true
		elseif p1 == keys.five or p1 == keys.numPad5 then
      keyCode = keyCode .. "5"
      isKeyingCode = true
		elseif p1 == keys.six or p1 == keys.numPad6 then
      keyCode = keyCode .. "6"
      isKeyingCode = true
		elseif p1 == keys.seven or p1 == keys.numPad7 then
      keyCode = keyCode .. "7"
      isKeyingCode = true
		elseif p1 == keys.eight or p1 == keys.numPad8 then
      keyCode = keyCode .. "8"
      isKeyingCode = true
		elseif p1 == keys.nine or p1 == keys.numPad9 then
      keyCode = keyCode .. "9"
      isKeyingCode = true
		elseif p1 == keys.zero or p1 == keys.numPad0 then
      keyCode = keyCode .. "0"
      isKeyingCode = true
		elseif isKeyingCode and p1 == keys.backspace then
      keyCode = string.sub(keyCode, 1, #keyCode-1)
      
		elseif p1 == keys.enter then
      doKeyingSubmit = true
      
      
		elseif p1 == keys.up and doDOMScroll(-1) then
      --doScrollPage = 1
      triggerDomRender = true
      
		elseif p1 == keys.down and doDOMScroll(1)  then
      --doScrollPage = -1
      triggerDomRender = true
      
		elseif p1 == keys.home then
      doJumpPage = 0
      
		elseif p1 == keys['end'] then
      doJumpPage = -totalLines
      
		elseif p1 == keys.r then
      updateTitleKeying(currentPageID)
      loadPage(currentPageID)
      triggerDomRender = true
      
		elseif p1 == keys.q then
      running = false
    end
  end
  
  --[[if doScrollPage ~= 0 and scrollPage(doScrollPage) then
    triggerDomRender = true
  end
  if doJumpPage < 1 and setPageScroll(getPageScroll(doJumpPage)) then
    triggerDomRender = true
  end]]
  
  if currentTime - lastUpdateTime > updateSpeed then
    lastUpdateTime = currentTime
    localFrame = localFrame + 1
    triggerDomRender = true
  end
  
  if isKeyingCode then
  
    --updateTitleKeying(keyCode)
    if #keyCode == 6 then
      doKeyingSubmit = true
    end
  
    if doKeyingSubmit then
      isKeyingCode = false
      currentPageID = lpad(keyCode, 6, "0")
      keyCode = ""
      loadPage(currentPageID)
      triggerDomRender = true
    end
  else
    if doKeyingSubmit and currentlySelected and currentlySelected:name() == "listing" then
      term.setTextColor(colors.black)
      term.setCursorPos(1,1)
      --print(currentlySelected["@id"])
      local tmpPageID = string.gmatch(currentlySelected["@id"], "%d+")()
      if tmpPageID ~= nil and tonumber(tmpPageID) >= 0 and tonumber(tmpPageID) < 1000000 then
        currentPageID = lpad(tmpPageID, 6, "0")
        updateTitleKeying(currentPageID)
        loadPage(currentPageID)
        triggerDomRender = true
      end
    end
  end 
  doKeyingSubmit = false
  
  if triggerDomRender then
    renderDOM(true)
    triggerDomRender = false
  end
  
  if isKeyingCode then
    updateTitleKeying(keyCode)
  end

  os.cancelTimer(timer)     -- our heatbeat
  timer = os.startTimer(updateSpeed) --  for animaions
  
  if debugSide then
    local monitor = peripheral.wrap( debugSide )
    if monitor then      
      monitor.setBackgroundColor(colors.black)
      monitor.setTextColor(colors.white)
      monitor.clear()
      monitor.setTextScale(0.5)
      monitor.setCursorPos(1,1)
      monitor.write( "DEBUG:" )
      local y = 1
      for k,v in pairs(debugOutput) do
        y = y + 1
        monitor.setCursorPos(1,y)
        monitor.write( string.format("%s: %s", k,v) )
      end
    end
  end
  
end

--saveSettings()
setColors(term, colors.black, colors.white, colors.black, colors.white)
term.clear()
term.setCursorPos(1,1)